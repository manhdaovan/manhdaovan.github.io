<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ManhDV's blog</title>
    <description>95% những điều họ nói về ManhDV là sai, chỉ có lúc nào cũng so high là đúng thật :v</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Higher-Order Function (HOF) và Currying</title>
        <description>&lt;p&gt;&lt;strong&gt;Bài viết khá dài và có nhiều chi tiết rất bình thường, hãy cân nhắc trước khi đọc :D&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;p&gt;Tôi cho rằng một kỹ sư phần mềm pro không phải là người viết ra những dòng code đánh đố người đọc hay đồng nghiệp,
mà là người viết những dòng code mà khi người khác đọc nó liền cảm thấy trong sáng, dễ hiểu, dễ bảo trì.&lt;/p&gt;

&lt;p&gt;Cũng như sự tiến hóa của con người, khi mà “ăn no, ăn sạch rồi ăn ngon”, thì coding cũng có slogan tương tự:
&lt;a href=&quot;http://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast&quot;&gt;“chạy được, chạy đúng, sau cùng là chạy nhanh”&lt;/a&gt;.
Vậy, sau khi chạy được và chạy đúng rồi, chúng ta nên suy nghĩ xem ngoài việc có thể chạy nhanh hơn ko,
thì đoạn code này đã sáng sủa chưa? Nếu bị/được sửa thì có dễ ko?&lt;/p&gt;

&lt;p&gt;HOF và Currying là 2 trong số ti tỉ kỹ thuật nhằm giúp chúng ta, những lập trình viên huyền thoại, đạt được tiêu chí trên.&lt;/p&gt;

&lt;p&gt;Trước khi đi vào khái niệm cụ thể, chúng ta cùng xem ví dụ dưới đây:&lt;/p&gt;

&lt;h3 id=&quot;ví-dụ-1&quot;&gt;Ví dụ 1&lt;/h3&gt;

&lt;p&gt;Nhóc con nhà bạn nhờ bạn tìm những số tự nhiên khác 0 nhỏ hơn 20 và là số lẻ.
Là một ông bố mẫu mực với niềm kiêu hãnh nhiều năm kinh nghiệm fixed hàng trăm bug nhỏ và &lt;del&gt;tạo ra&lt;/del&gt; hàng tá bug to,
bạn muốn viết một chương trình hoành tráng để lấy le với con mình. Ok, you win!.
Dưới đây chắc hẳn là đoạn code đầu tiên xuất hiện trong đầu:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function pickOddNumbers(maximum) {
  const result = [];

  for (let i = 1; i &amp;lt;= maximum; i += 1) {
    if (i % 2 === 1) result.push(i);
  }

  return result;
}

pickOddNumbers(20);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nhưng đời không bao giờ là mơ, khi hôm sau nhóc con lại mếu máo: “Cô giáo cho thêm bài: Tìm những số tự nhiên khác 0 nhỏ hơn 20 mà nếu gấp 3 số đó rồi từ đi 2 thì thu được số chẵn.”.
Ok bố chiều cô luôn. Vậy là bạn lại cho ra phiên bản mới:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function pickSpecialNumbers(maximum) {
  const result = [];

  for (let i = 1; i &amp;lt;= maximum; i += 1) {
    if (((i * 3) - 2) % 2 === 0) result.push(i);
  }

  return result;
}

pickSpecialNumbers(20);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Đời vẫn ko như mơ khi cô giáo lại cho thêm bài tập: “Tìm những số tự nhiên khác 0 nhỏ hơn 20 mà nếu lấy phần dư số đó cho 9 rồi cộng thêm 2 thì thu số lẻ.”
Ơ cô giáo từ từ, để bố em sửa function bên trên đã :))))&lt;/p&gt;

&lt;p&gt;Cứ như vậy, mỗi lần cô giáo cho thêm yêu cầu là bạn lại phải sửa phiên bản cũ hoặc cho ra một bản mới,
tuy yêu cầu khác nhau nhưng xử lý cơ bản là giống nhau, chỉ khác ở đoạn xử lý điều kiện cho số được chọn.
Và bạn chợt nhớ tới HOF, một ứng cử viên sáng giá cho việc làm đoạn code trên sạch hơn, gọn hơn, dễ sửa hơn.&lt;/p&gt;

&lt;h3 id=&quot;định-nghĩa-hof&quot;&gt;Định nghĩa HOF&lt;/h3&gt;

&lt;p&gt;Theo &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;wikipedia&lt;/a&gt; thì:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A higher-order function (also functional, functional form or functor) is a function that does at least one of the following:

・takes one or more functions as arguments,
・returns a function as its result.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Vietsub:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HOF là một function mà cho phép thực hiện ít nhất 1 trong 2 khả năng sau:
・Nhận vào một hoặc nhiều function như là tham số, hoặc/và
・Trả về kết quả là một function.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;// Bạn có thể thấy có rất nhiều ngôn ngữ hỗ trợ HOF ở link wiki trên. Đến Java còn hỗ trợ nữa là :v&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Trăm nghe không bằng một thấy, trăm thấy không bằng một sờ, và chúng ta lại cùng sờ với ví dụ bên trên.
Lần này là bản nâng cấp có giá trị về mặt học thuật, vì được áp dụng HOF vào cơ mà :)))&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function pickNumbers(maximum, pickingCondition) {
  const result = [];

  for (let i = 1; i &amp;lt;= maximum; i += 1) {
    if (pickingCondition(i)) result.push(i);
  }

  return result;
}

// Chọn ra những số lẻ
pickNumbers(20, function(number) {
  return number % 2 === 1;
});

// Chọn ra những số mà gấp 3 số đó rồi trừ đi 2 thu số chẵn
pickNumbers(20, function(number) {
  return ((number * 3) - 2) % 2 === 0;
});

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Với việc đưa HOF vào function bên trên, giờ thì cô giáo thích gì cũng chiều được nhé,
chỉ cần thay đổi function kiểm tra điều kiện vào thôi, ko cần phải copy thành function mới nữa.&lt;/p&gt;

&lt;h3 id=&quot;định-nghĩa-currying&quot;&gt;Định nghĩa Currying&lt;/h3&gt;

&lt;p&gt;Lại theo &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Currying is the technique of translating the evaluation of a function
 that takes multiple arguments (or a tuple of arguments)
 into evaluating a sequence of functions, each with a single argument.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Vietsub:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Currying là kỹ thuật mà cho phép chuyển đổi một function với nhiều tham số
thành những functions liên tiếp có một tham số.
// Ví dụ f(a,b,c) có thể được convert thành g(a)h(b, c) hay g(a)h(b)k(c), thậm chí là đổi thứ tự của các function tương ứng...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Vậy dễ dàng nhận thấy &lt;code class=&quot;highlighter-rouge&quot;&gt;Currying&lt;/code&gt; là một trường hợp của &lt;code class=&quot;highlighter-rouge&quot;&gt;HOF&lt;/code&gt;, vì nó thỏa mãn điều kiện &lt;code class=&quot;highlighter-rouge&quot;&gt;trả về kết quả là một function&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cụ thể áp dụng cho ví dụ trên, có thể viết thành dạng sau:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function pickNumbers(maximum) {
  return function (pickingCondition) {
    const result = [];

    for (let i = 1; i &amp;lt;= maximum; i += 1) {
      if (pickingCondition(i)) result.push(i);
    }

    return result;
  };
}

// Chọn ra những số lẻ
pickNumbers(20)(function (number) {
  return number % 2 === 1;
});

// Chọn ra những số mà gấp 3 số đó rồi trừ đi 2 thu số chẵn
pickNumbers(20)(function (number) {
  return (number * 3 - 2) % 2 === 0;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So sánh ví dụ áp dụng Currying này với ví dụ sử dụng HOF ở trên, rõ ràng là ta chưa thấy sự ưu việt của Currying so với HOF, thậm chí còn thấy hơi rườm rà nữa.
Tuy nhiên, hãy cùng xem xét ví dụ dưới đây:&lt;/p&gt;

&lt;h3 id=&quot;ví-dụ-2&quot;&gt;Ví dụ 2&lt;/h3&gt;

&lt;p&gt;Viết một function lấy ra giá trị của một &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; của object, được chọn ra từ một mảng các objects với điều kiện. Đơn giản vậy thôi, nên việc cài đặt cũng có vẻ là đơn giản.&lt;/p&gt;

&lt;p&gt;Với HOF:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getValue(objects, key, pickingCondition) {
  var object = null;

  for (var i = 0; i &amp;lt; objects.length; i++) {
    if (pickingCondition(objects[i])) {
      object = objects[i];
      break;
    }
  }

  return object ? object[key] : null;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Mỗi khi gọi function với key khác nhau, hẳn là sẽ phải gọi kiểu như vầy:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var valueByKey1 = getValue(objects, 'key1', pickingCondition);
var valueByKey2 = getValue(objects, 'key2', pickingCondition);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nếu như coi &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; là &lt;strong&gt;biết trước&lt;/strong&gt;, chỉ thay đổi &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;pickingCondition&lt;/code&gt;, thì việc áp dụng Currying lại hợp lý:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getValue(key) {
  return function (objects, pickingCondition) {
    let object = null;

    for (let i = 0; i &amp;lt; objects.length; i++) {
      if (pickingCondition(objects[i])) {
        object = objects[i];
        break;
      }
    }

    return object ? object[key] : null;
  };
};

// Wrap getValue thành những function ngắn hơn với tên sáng nghĩa:
var getValueByKey1 = getValue('key1');
var getValueByKey2 = getValue('key2');

// Sử dụng:
var valueByKey1 = getValueByKey1(objects, pickingCondition);
var valueByKey2 = getValueByKey2(objects, pickingCondition);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Khá là gọn gàng.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;// Ngoài lề: Nếu bạn làm việc với ReactJs, hẳn bạn đã biết tới thuật ngữ Higher-Order Component,
hay các selectors mà redux-form cung cấp, thì chúng đều áp dụng kỹ thuật Currying này, cũng như HOF.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Dưới đây là một vài ví dụ cho thấy tác dụng tốt của Currying:&lt;/p&gt;

&lt;h3 id=&quot;ví-dụ-3&quot;&gt;Ví dụ 3&lt;/h3&gt;

&lt;p&gt;Viết function để kiểm tra độ dài của một xâu &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; có vượt quá &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; hay ko.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Cách 1: Không dùng Currying
function isLengthOver(s, n){
  return s.length &amp;gt; n
}

// Cách 2: Có Currying
function isLengthOver(n){
  return function(s){
    return s.length &amp;gt; n;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Giả sử cả 2 cách viết trên được sử dụng cho việc validate của một field trên form, với &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 10&lt;/code&gt; thì có sự khác biệt như sau:&lt;/p&gt;

&lt;p&gt;Với cách 1:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; validate={value =&amp;gt; isLengthOver(value, 10)} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Với cách 2:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; validate={isLengthOver(10)} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Quá khác bọt!&lt;/p&gt;

&lt;h3 id=&quot;ví-dụ-4&quot;&gt;Ví dụ 4&lt;/h3&gt;

&lt;p&gt;Viết function hiển thị tên group mà một nhân viên đang làm việc, với:&lt;/p&gt;

&lt;p&gt;Input:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;employeeGroupId&lt;/code&gt; là id của group mà nhân viên đang làm việc,&lt;/li&gt;
  &lt;li&gt;Mảng chứa toàn bộ &lt;code class=&quot;highlighter-rouge&quot;&gt;groups&lt;/code&gt; có trong công ty.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Điều kiện rằng buộc:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Một group luôn có id khác null,&lt;/li&gt;
  &lt;li&gt;Nếu groupB là group con của groupA, thì groupB sẽ có &lt;code class=&quot;highlighter-rouge&quot;&gt;parentGroupId&lt;/code&gt; là id của groupA. Group không là con khi &lt;code class=&quot;highlighter-rouge&quot;&gt;parentGroupId&lt;/code&gt; của nó là null,&lt;/li&gt;
  &lt;li&gt;Không có quan hệ vòng tròn. (Kiểu: &lt;code class=&quot;highlighter-rouge&quot;&gt;groupA là con groupB, groupB là con groupC, groupC là con groupA&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Full path của group mà nhân viên đang làm việc, phân cách bởi dấu &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;. Ví dụ &lt;code class=&quot;highlighter-rouge&quot;&gt;Group A / Group B / Group C&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chắc hẳn bạn sẽ nghĩ tới cách dùng vòng lặp, kiểm tra chừng nào còn tìm thấy group có id bằng &lt;code class=&quot;highlighter-rouge&quot;&gt;parentGroupId&lt;/code&gt;. Và tôi cũng nghĩ vậy :D&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const getGroupFullPathName = (groups, employeeGroupId) =&amp;gt; {
  const groupNames = [];

  let group = groups.find(grp =&amp;gt; grp.id === employeeGroupId);
  while (group) {
    groupNames.unshift(group.name);
    group = groups.find(grp =&amp;gt; grp.id === group.parentGroupId);
  }

  return groupNames.join('/');
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nhưng đoạn code trên vẫn chưa ngon, do vi phạm rule &lt;a href=&quot;https://eslint.org/docs/rules/no-loop-func&quot;&gt;Don’t make functions within a loop&lt;/a&gt; của ESLint.
Cụ thể: Mỗi khi vòng while được chạy thì &lt;code class=&quot;highlighter-rouge&quot;&gt;groups.find(grp =&amp;gt; grp.id === group.parentGroupId)&lt;/code&gt; lại sinh ra một anonymous function, chính là &lt;code class=&quot;highlighter-rouge&quot;&gt;grp =&amp;gt; grp.id === group.parentGroupId&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cách khắc phục là ta viết một currying bên ngoài vòng while là được:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const getGroupFullPathName = (groups, employeeGroupId) =&amp;gt; {
  const groupNames = [];
  const condition = parentGroupId =&amp;gt; group =&amp;gt; group.id === parentGroupId;

  let group = groups.find(grp =&amp;gt; grp.id === employeeGroupId);
  while (group) {
    groupNames.unshift(group.name);
    group = groups.find(condition(group.parentDepartmentId));
  }

  return groupNames.join('/');
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;kết-luận&quot;&gt;Kết luận:&lt;/h3&gt;
&lt;p&gt;Bài quá dài.&lt;/p&gt;

</description>
        <pubDate>Sat, 14 Oct 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/programming/vi/2017/10/14/higer-order-function-and-currying/</link>
        <guid isPermaLink="true">http://localhost:4000/programming/vi/2017/10/14/higer-order-function-and-currying/</guid>
      </item>
    
      <item>
        <title>Kỹ thuật sửa lỗi Reed - Solomon</title>
        <description>&lt;p&gt;Đây là bài viết thuộc chủ đề nghiên cứu của nhóm ruby &lt;a href=&quot;https://github.com/ruby-vietnam/hardcore-rule&quot;&gt;hardcore&lt;/a&gt;,
được lược dịch chủ yếu từ &lt;a href=&quot;https://www.cs.cmu.edu/~guyb/realworld/reedsolomon/reed_solomon_codes.html&quot;&gt;bài viết này.&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;
&lt;p&gt;Là người  dùng cuối, chúng ta đã quá quen thuộc với việc click vào nút download A,
quét một mã vạch B hay mua một cái đĩa CD C, thì chúng ta đều nhận được một kết quả thích hợp và đầy đủ dữ liệu.
Hầu như tải về là cài đặt được, quét mã qr là hiện ra thông tin được, mua đĩa CD về là nghe được, vân vân…
Nhưng hậu trường đằng sau của những sự tưởng như bình thường đó không hề bình thường chút nào, vì mọi thứ trên đời đều có khả năng phát sinh lỗi.
Và làm sao có thể hạn chế tối đã những lỗi này, thậm chí ưu việt hơn là phát hiện ra lỗi và tự sửa nó, là một vấn đề rất khó.&lt;/p&gt;

&lt;p&gt;Reed-solomon là một kỹ thuật trong &lt;a href=&quot;https://en.wikipedia.org/wiki/Forward_error_correction#List_of_error-correcting_codes&quot;&gt;rất nhiều kỹ thuật&lt;/a&gt; nhằm đảm bảo toàn vẹn dữ liệu.
Nó cho phép phát hiện và sửa lỗi, được ứng dụng rất rộng rãi, từ những sản phẩm rất bình dân mà bạn thấy hằng ngày như đĩa CD, DVD,
cao cấp hơn tí có mã QR, hay các công nghệ phức tạp như DSL, WiMAX, RAID 6,
thậm chí cả &lt;a href=&quot;http://antoanthongtin.vn/Detail.aspx?NewsID=05a52da7-ee6a-4578-8792-1d3b471c18f9&amp;amp;CatID=43b7448c-0f7e-4558-a39f-1d209751aad2&quot;&gt;công nghệ vũ trụ&lt;/a&gt;…&lt;/p&gt;

&lt;p&gt;Tưởng tượng một chút là ta mua cái đĩa về, mở lên thấy Ưng Hoàng Phúc hát mà thỉnh thoảng lại thấy giọng của Ngọc Trinh thì hay nhỉ :D&lt;/p&gt;

&lt;h3 id=&quot;nguyên-lý-chung&quot;&gt;Nguyên lý chung&lt;/h3&gt;

&lt;p&gt;Cứ tưởng tượng thế này cho dễ. Trong 1 đoàn quân gửi đi đánh nhau, rất có thể có những người lính biến chất dọc đường.
Làm sao để phát hiện và khôi phục lòng trung thành của những người lính này, thì bạn phải cài cắm người mà bạn tin vào trong đoàn quân đó,
để chúng giám sát và báo lại cho bạn nếu có việc trên.
Xịn hơn nữa, người được cài cắm có thể tự động khuyên nhủ mấy anh lính hư kia, đưa đoàn quân trở lại sự trung thành nhất, ko còn tạp chất.&lt;/p&gt;

&lt;p&gt;Tư tưởng của kỹ thuật Reed-Solomon cũng vậy. Khi bạn gửi một số bit trên đường truyền (=gửi quân đi đánh),
rất có thể có những bit bị sai lệch vì nhiễu trên kênh truyền (=lính biến chất),
bạn sẽ phải đưa thêm những bit giám sát (=cài cắm người mà bạn tin) vào số bit trên, và truyền tải đi.&lt;/p&gt;

&lt;p&gt;Việc cài cắm sẽ được thông qua bộ &lt;strong&gt;encoder&lt;/strong&gt;, và bộ &lt;strong&gt;decoder&lt;/strong&gt; sẽ lo việc khôi phục.&lt;/p&gt;

&lt;h3 id=&quot;các-khái-niệm-kỹ-thuật-liên-quan&quot;&gt;Các khái niệm kỹ thuật liên quan&lt;/h3&gt;

&lt;p&gt;Theo định nghĩa xịn ở &lt;a href=&quot;https://www.cs.cmu.edu/~guyb/realworld/reedsolomon/reed_solomon_codes.html&quot;&gt;đây&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A Reed-Solomon code is specified as RS(n,k) with s-bit symbols.

This means that the encoder takes k data symbols of s bits each and adds parity symbols to make an n symbol codeword.
There are n-k parity symbols of s bits each. A Reed-Solomon decoder can correct up to t symbols that contain errors in a codeword, where 2t = n-k.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Vietsub:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mã Reed-Solomon được đặc tả là RS(n,k), với mỗi ký tự được cấu tạo từ s-bit.
Nghĩa là bộ mã hóa sẽ nhận k ký tự, sau đó thêm vào các ký tự kiểm tra để tạo ra codeword có độ lớn n ký tự.
Số ký tự kiểm tra là `n-k`, và số ký tự có thể được sửa tối đa là (n-k)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ta có thể liên tưởng đến các khái niệm được nhắc tới với nguyên lý chung ở trên như sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;symbols(ký tự):&lt;/strong&gt; Có ý nghĩa như một anh lính. Anh lính này (symbol) được cấu tạo từ s-bit.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;k data symbols:&lt;/strong&gt; Có ý nghĩa như một đoàn quân trước khi được cài cắm người vào. Đoàn quân này có số lượng là &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; anh lính.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;n symbol codeword:&lt;/strong&gt; Có ý nghĩa như đoàn quân &lt;strong&gt;sau khi cài cắm người vào&lt;/strong&gt;, có số lượng là &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; anh lính. (n &amp;gt; k)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;n-k parity symbols(ký tự kiểm tra):&lt;/strong&gt; Số lính mà ta cài cắm vào đoàn quân. Tất nhiên mỗi anh lính được cài vào vẫn được cấu tạo từ s-bit.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2t = n-k:&lt;/strong&gt; Reed-Solomon có thể sửa được &lt;strong&gt;tối đa&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; anh lính (symbols) biến chất trong đoàn quân, với &lt;code class=&quot;highlighter-rouge&quot;&gt;2t = n - k&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Người ta bảo trăm nghe ko bằng một thấy, vậy dưới đây là hơn 100 lần nghe :v&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/assets/reed_solomon_code_word.gif&quot; alt=&quot;Hình minh họa cấu tạo RS codeword&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;một-số-tính-chất&quot;&gt;Một số tính chất&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Với một ký tự(symbol) được tạo nên từ s-bit, thì codeword n có độ dài ko quá $n=2^{s}\; -\; 1$
Ví dụ một ký tự có độ dài 8 bit (s=8) thì n &amp;lt;= 2^8 -1 = 255.
Một mã RS điển hình là RS(255,223), ta sẽ có: n = 255, k = 223, s = 8, 2t = 32, t = 16&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Một symbol được coi là bị lỗi nếu 1 bit trong nó là lỗi hoặc tất cả các bit trong symbol đó là lỗi.
Như vậy, với ví dụ cho RS(255,223) ở trên, mã RS này có thể sửa được 16 symbol lỗi (t=16).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Trong trường hợp xấu nhất, có 16 symbol riêng biệt nhau bị lỗi, và chỉ lỗi có 1 bit thôi.
Lúc này, bộ giải mã chỉ có thể sửa được 16 * 1 = 16 bit lỗi.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nhưng nếu như tất cả bit của cả 16 symbol đều lỗi, thì bộ decoder có thể sửa tới 16 * 8 = 128 bit lỗi.
Vậy dễ nhận thấy là mã RS sẽ rất đắc lực trong trường hợp mà chuỗi các bit liên tiếp nhau bị lỗi.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Một symbol được coi là bị xóa nếu như biết được vị trí của symbol bị xóa.
Bộ decoder có thể sửa được tối đa t symbol lỗi và 2t symbol bị xóa.
Khi dữ liệu đi qua bộ decoder sẽ có 3 trường hợp xảy ra:&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;2e + r &amp;lt; 2t với e là số symbol lỗi, r là số symbol bị xóa, thì codeword n luôn đc bảo đảm là đúng.&lt;/li&gt;
  &lt;li&gt;Ngược lại, decoder sẽ báo là không thể khôi phục dữ liệu, hoặc:&lt;/li&gt;
  &lt;li&gt;decoder sẽ decode và khôi phục sai dữ liệu. Đây là trường hợp khi mà chính &lt;strong&gt;parity symbols&lt;/strong&gt;
mà chúng ta thêm vào bị lỗi trong quá trình truyền tải. (Đến người mình tin yêu còn phản mình thì có mà bấu víu vào trời :v)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cài-đặt-cụ-thể&quot;&gt;Cài đặt cụ thể&lt;/h3&gt;

&lt;p&gt;Phần này rất dài, và đặc toán là toán, bạn nào dễ bị đau đầu thì ko nên đọc.
Còn bạn nào đầu cứng thì có thể tham khảo ở link:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.m.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders&quot;&gt;https://en.m.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.thonky.com/qr-code-tutorial/error-correction-coding&quot;&gt;http://www.thonky.com/qr-code-tutorial/error-correction-coding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2 ví dụ trên tác giả viết rõ cho trường hợp áp dụng cho QR code,
cũng như giải thích cặn kẽ các kiến thức toán học liên quan, rất đáng tham khảo nếu đi sâu vào tìm hiểu QR.&lt;/p&gt;

&lt;h3 id=&quot;một-số-kết-luận-tóm-gọn&quot;&gt;‎Một số kết luận tóm gọn&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Cost càng ngày càng tăng nếu data càng dài (hiển nhiên luôn)&lt;/li&gt;
  &lt;li&gt;Encoding đã khó, decoding còn khó hơn nhiều :v&lt;/li&gt;
  &lt;li&gt;Rất nhiều kiến thức toán cao cấp của năm 1 2 đại học được áp dụng như Vành đa thức (univariate polynomials),
tập hữu hạn và các phép toán trên tập hữu hạn (finite fields)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS: trên ruby cũng có &lt;a href=&quot;https://github.com/whomwah/rqrcode&quot;&gt;lib generate string sang QR code&lt;/a&gt;
với format png, ansi… mà mình cũng đang sử dụng cho &lt;a href=&quot;https://anychat.4me.tips/&quot;&gt;Anychat&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 24 Sep 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/math/advance/2017/09/24/reed-solomon-error-correction/</link>
        <guid isPermaLink="true">http://localhost:4000/math/advance/2017/09/24/reed-solomon-error-correction/</guid>
      </item>
    
      <item>
        <title>Vài suy nghĩ về nghề Lập Trình Viên (LTV)</title>
        <description>&lt;p&gt;#opinion #vi #cntt #ltv&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LTV được nhắc tới trong bài được gói gọn trong ngữ cảnh của LTV Phần mềm.
Mọi ý kiến trong bài đều dựa trên góc nhìn của người viết, không có ý gây ra những tranh luận tiêu cực không đáng có.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tldr&quot;&gt;TL;DR:&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LTV là nghề đáng làm, vì:
  * Không có trăn trở quá lớn về đạo đức
  * Không tổn thật hoặc tổn thất ít tài nguyên khi thử nghiệm hoặc thử nghiệm thất bại
  * Không yêu cầu quá nhiều thể lực
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Anh nhà bác tôi sang năm thi đại học. Bác tôi có hỏi là giờ nên cho anh mày học cái gì, tôi mạnh dạn: “Để anh ấy học CNTT đi bác”.&lt;/p&gt;

&lt;p&gt;Nghề LTV có nhiều tên gọi biến thể hoặc mở rộng, nâng cấp khác như Coder, Developer, Software Engineer…, là một nghề trong lĩnh vực khoa học kỹ thuật.
Tựu trung lại thì những nghề trên nói riêng, hay mọi nghề liên quan đến lĩnh vực khoa học kỹ thuật nói chung, đề là nghề đáng làm, rất đáng làm, do nó có các đặc điểm sau:&lt;/p&gt;

&lt;h3 id=&quot;không-có-trăn-trở-quá-lớn-về-mặt-đạo-đức&quot;&gt;Không có trăn trở quá lớn về mặt đạo đức&lt;/h3&gt;

&lt;p&gt;Trong nghề LTV này, thành tựu và năng lực của một cá nhân được thể hiện rất rõ ràng, khó có thể bị hiểu một cách nhập nhằng. Thậm chí có câu nói: “&lt;a href=&quot;https://en.wikiquote.org/wiki/Linus_Torvalds&quot;&gt;Talk is cheap. Show me the code.&lt;/a&gt;” kinh điển.
Do là ngành mang đậm tính khoa học tự nhiên, nên kết quả chỉ có đúng/sai, không có khái niệm &lt;strong&gt;có vẻ đúng&lt;/strong&gt; hay &lt;strong&gt;gần đúng rồi&lt;/strong&gt; nào cả. Và tất nhiên, câu thần chú &lt;strong&gt;nhất quan hệ, nhì tiền tệ&lt;/strong&gt; không có cửa áp dụng ở đây.
Để lên được trình độ cao trong ngành, trong nghề, chỉ có con đường duy nhất là tạo ra những dòng code, những kiến trúc tốt, những sản phẩm có chất lượng cao. Tất nhiên, nếu rẽ hướng sang con đường làm quản lý thì lại là chuyện khác hẳn.&lt;/p&gt;

&lt;p&gt;Nói đến đây thì hẳn người đọc sẽ có suy nghĩ: “Nghề nào mà chả vậy, giỏi là được”. Đúng. Nhưng ý của người viết là để được công nhận là giỏi trong nghề LTV này, thì ko cần cầu cạnh ai cả, cứ tạo ra những dòng code chói lòa, và để những người cùng nghề đánh giá :D&lt;/p&gt;

&lt;h3 id=&quot;không-tổn-thật-hoặc-tổn-thất-ít-tài-nguyên-khi-thử-nghiệm-hoặc-thử-nghiệm-thất-bại&quot;&gt;Không tổn thật hoặc tổn thất ít tài nguyên khi thử nghiệm hoặc thử nghiệm thất bại&lt;/h3&gt;

&lt;p&gt;Khi cá nhân có ý tưởng, hay đơn giản chỉ là muốn thử nghiệm cái mà bản thân chưa biết, thì làm điều này đối với nghề LTV luôn mang lại những trải nghiệm an toàn.
An toàn ở chỗ là dù có làm sai, làm hỏng, chọc ngoáy đủ kiểu, thì thứ tốn kém chỉ là thời gian mà thôi. Chuyện gì sẽ xảy ra nếu như bạn xây sai một bức tường? Chỉ có đập. Đập nghĩa là ngoài thời gian đã bỏ ra, còn là gạch, vữa…
Như vậy, ở một khía cạnh này, thì nghề LTV luôn khuyến khích mọi người thử nghiệm và học những cái mới nhanh chóng và an toàn.
Và chỉ có vọc vạch thì tay nghề mới lên được.&lt;/p&gt;

&lt;h3 id=&quot;không-yêu-cầu-quá-nhiều-thể-lực&quot;&gt;Không yêu cầu quá nhiều thể lực&lt;/h3&gt;

&lt;p&gt;Ngắn gọn thôi: Với người chỉ cao 1m60 và nặng chưa bằng 1 bao xi măng như người viết còn làm được nghề này, thì ai chẳng làm được :v&lt;/p&gt;

&lt;h3 id=&quot;ngoài-lề&quot;&gt;Ngoài lề&lt;/h3&gt;

&lt;p&gt;Nghề LTV là nghề đáng làm, không có nghĩ nó là nghề &lt;strong&gt;việc nhẹ lương cao&lt;/strong&gt; (Cụm từ này là cụm từ người viết căm ghét nhất từ lúc đi làm tới giờ, sẽ được giải thích ở post khác)
Nó có những đặc thù riêng, với những chuẩn bị cũng khác nữa.&lt;/p&gt;

</description>
        <pubDate>Sun, 24 Sep 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/opinion/vi/2017/09/24/nghe-lap-trinh-vien/</link>
        <guid isPermaLink="true">http://localhost:4000/opinion/vi/2017/09/24/nghe-lap-trinh-vien/</guid>
      </item>
    
      <item>
        <title>Xây dựng ứng dụng chat sử dụng websocket có khó không?</title>
        <description>&lt;p&gt;#tech #realtime #chatting #rails #actioncable #vi&lt;/p&gt;

&lt;p&gt;Cảnh báo: Mục đích của bài viết hơi bị lườm rau gắp thịt với tiêu đề.&lt;/p&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Bạn là người chưa nổi tiếng tới mức có trên trên wikipedia, nhưng vẫn là idol trong một group nào đó, như &lt;a href=&quot;http://ruby.org.vn/&quot;&gt;Ruby Vietnam&lt;/a&gt; chẳng hạn, và nhận được hàng tá câu hỏi của newbie. Bạn rất muốn trả lời, nhưng lại không muốn share FB/email account?&lt;/li&gt;
  &lt;li&gt;Bạn mới gặp một em gái kute dễ thương, muốn nói chuyện lắm mà lại sợ em ấy bắt gặp mình đi công tác ở Trần D** H**g, nên ko dám cho số điện thoại?&lt;/li&gt;
  &lt;li&gt;Bạn đơn giản chỉ muốn sau cuộc nói chuyện thì mọi thứ liên quan đến cuộc nói chuyện đó đều về với mây?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://anychat.4me.tips/&quot;&gt;Anychat&lt;/a&gt; chính là dành cho bạn.&lt;/p&gt;

&lt;h3 id=&quot;một-số-tính-năng-đặc-sắc&quot;&gt;Một số tính năng đặc sắc&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Do là tính năng chat ẩn danh, nên người khác không thể thấy bất cứ thông tin gì về profile của bạn, ngoại trừ &lt;strong&gt;username&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Vì thế, thay vì đọc cái nick &lt;strong&gt;trAiX0mnGHeO&lt;/strong&gt; cho cô bạn gái mới quen chép lại, thì chỉ việc vào mục &lt;strong&gt;Profile &amp;gt; Settings&lt;/strong&gt; rồi chìa cái QR code ra cho cô em quét cái bíp là xong.&lt;/li&gt;
  &lt;li&gt;Thế khi offline mà có người khác nhắn tới thì có biết không? &lt;strong&gt;Có&lt;/strong&gt; và &lt;strong&gt;Không&lt;/strong&gt;. Có là khi ở &lt;strong&gt;Profile &amp;gt; Settings&lt;/strong&gt; bạn nhập email của mình vào, và đồng ý nhận tin nhắn khi offline, thì chỉ và chỉ một tin nhắn đầu tiên của người khác sẽ được gửi tới email này. Tất nhiên &lt;strong&gt;Không&lt;/strong&gt; cho trường hợp còn lại. Và email này chỉ có mình bạn mới thấy thôi, ngoài ra không ai có thể xem được cả.&lt;/li&gt;
  &lt;li&gt;Nhắc lại một tiêu chí ở background là: Khi bạn thoát, hoặc tắt trình duyệt đi, thì mọi thứ liên quan đến cuộc nói chuyện đều bị xoá hết, bảo đảm chỉ có mình bạn và đối tác biết mà thôi.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stack-sử-dụng-và-các-thông-tin-liên-quan&quot;&gt;Stack sử dụng và các thông tin liên quan&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Nginx&lt;/strong&gt;: Vai trò làm reverse proxy, forward request cho Puma bên dưới.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Puma&lt;/strong&gt;: Làm application server, hứng request nhận được từ nginx đưa vào app xử lý, trả kết quả về cho nginx.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rails 5.0.2 with ActionCable&lt;/strong&gt;: Con tim của ứng dụng :v. ActionCable là module nơi có build-in websocket sẽ được sử dụng cho chức năng realtime chat. Mọi chức năng khác như login, check online/offline, gửi tin nhắn đầu tiên khi offline… do Rails app đảm nhiệm.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt;: Do websocket không có session, nên muốn dùng chung với cái gì đó với app thì phải đi qua storage thứ 3. Mình chọn redis một phần cũng vì default stack của ActionCable có dùng redis nữa.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MySQL&lt;/strong&gt;: Chỉ dùng để lưu username/password (hashed). Nếu bạn muốn tự cài đặt thành server của mình, và lượng user không lớn, thì nên dùng sqlite thay thế, đỡ tốn resource để chạy MySQL service.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kết-luận&quot;&gt;Kết luận&lt;/h3&gt;

&lt;p&gt;Đến giờ thì mới là câu trả lời cho câu hỏi ở tiêu đề. Theo mình là dễ và khó :v&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dễ vì nếu chỉ làm theo tutorial và một service có chức năng đơn giản thì dễ.&lt;/li&gt;
  &lt;li&gt;Khó là khi kể cả chưa nhắc tới quy mô, thì việc tích hợp với một số tính năng bên lề xoay quanh user đang tương tác là khó. Vì websocket ko có session, nên mọi thông tin nhặt được từ client bằng cookie mà thôi. Vì vậy mà việc expired session sẽ có khó khăn hơn khi không có tích hợp websocket vào cùng.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://anychat.4me.tips/rooms/manhdv&quot;&gt;manhdv@anychat&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sourcecode của &lt;a href=&quot;https://anychat.4me.tips/&quot;&gt;Anychat&lt;/a&gt; được public trên &lt;a href=&quot;https://github.com/manhdaovan/anychat&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;All pull requests, issues, stars are welcome!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Apr 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/tech/rails/actioncable/2017/04/07/Realtime-chat-voi-websocket/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/rails/actioncable/2017/04/07/Realtime-chat-voi-websocket/</guid>
      </item>
    
      <item>
        <title>Pinterest đã thực hiện scaled MySQL của họ như thế nào</title>
        <description>&lt;p&gt;#tech #summary #mysql #vi&lt;/p&gt;

&lt;h3 id=&quot;tl-dr&quot;&gt;TL; DR&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Cấu hình master-master trên nhiều node EC2&lt;/li&gt;
  &lt;li&gt;Mỗi node có nhiều database, với schema giống hệt nhau.&lt;/li&gt;
  &lt;li&gt;Thực hiện điều phối việc read/write bằng cách tạo UUID cho từng record.&lt;/li&gt;
  &lt;li&gt;Sử dụng duy nhất column text blob data cho việc lưu mọi thông tin liên quan đến object dưới dạng JSON.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;p&gt;Với ứng dụng web có traffic lớn thì việc scale là không thể tránh khỏi. Scale thì có thể tiến hành trên nhiều tầng, như tầng app, tầng db. Và theo mình thì scale ở tầng DB vẫn luôn là bài toán khó nhất. Vậy chúng ta cùng xem các kỹ sư tại &lt;a href=&quot;https://www.pinterest.com/&quot;&gt;Pinterest&lt;/a&gt; vì sao họ lại phải scale Mysql và họ đã thực hiện như thế nào.&lt;/p&gt;

&lt;p&gt;Bài viết lược dịch từ &lt;a href=&quot;https://medium.com/@Pinterest_Engineering/sharding-pinterest-how-we-scaled-our-mysql-fleet-3f341e96ca6f#.tm4mul2g2&quot;&gt;Sharding Pinterest: How we scaled our MySQL fleet&lt;/a&gt;, một bài viết theo mình đánh giá là rất chất lượng, và có nhiều giá trị có thể tham khảo.&lt;/p&gt;

&lt;p&gt;Mình sẽ ko dịch nguyên xi, mà sẽ đi vào nét chính là &lt;strong&gt;Why&lt;/strong&gt; and &lt;strong&gt;How&lt;/strong&gt;, 2 câu hỏi điển hình mỗi khi ta định thực hiện việc gì đó. Đồng thời mình sẽ giải thích/mở rộng luôn những chỗ có khó hiểu (với bản thân mình) khi vừa đọc lần đầu.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;// Pinterest đã lauch architecture này từ đầu năm 2012, và hệ thống vẫn ngon cho tới bây giờ.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;why&quot;&gt;Why&lt;/h3&gt;

&lt;p&gt;Trước thời điểm tiến hành “cải tổ”, Pinterest có:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hơn 50 tỷ pin được pin vào khoảng 1 tỷ board (mỗi user có nhiều boards, mỗi board có nhiều pins), và có nhiều thông tin râu ria như repin, like pin …&lt;/li&gt;
  &lt;li&gt;Họ đã dùng một số công nghệ NoSQL, và tất nhiên cả mô hình master-slave kinh điển nữa, nhưng tất cả vẫn ko đáp ứng đủ với lượng dữ liệu trên. Cái thì break, cái thì lỗi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vì vậy họ phải nghĩ tới 1 phương án mới, với các tiêu chí sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hệ thống phải ổn định, dễ vận hành, và dễ scale.&lt;/li&gt;
  &lt;li&gt;Mọi thông tin mà Pinner (có thể hiểu là user) tạo ra phải đảm bảo có thể được accesss mọi lúc.&lt;/li&gt;
  &lt;li&gt;Support việc query N pins trên một board đảm bảo theo 1 thứ tự cho trước (theo thời gian tạo pin hoặc theo 1 tiêu chí mà user đề ra)&lt;/li&gt;
  &lt;li&gt;Nếu phải update, thì việc update phải là đơn giản nhất có thể.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Một số suy luận và định hướng mà họ nhận ra khi tiến hành sharding:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Một khi đã shard, họ sẽ ko thể sử dụng joins, foreign keys, hoặc index một cách global được. (Vì data đã được chia thành các “cục” nhỏ, isolate với nhau). Tất nhiên, họ vẫn có thể sử dụng các chức năng này với data cục bộ.&lt;/li&gt;
  &lt;li&gt;Load balancing vẫn là cần thiết sau khi shard. Không để trường hợp node này quá đầy, node kia lại ko có gì.&lt;/li&gt;
  &lt;li&gt;Những nodes cần có tính ổn định cao.&lt;/li&gt;
  &lt;li&gt;Một khi đã shard, thì ko sờ vào data ở slave nữa. Mọi action read/write đều tiến hành trên master hết.&lt;/li&gt;
  &lt;li&gt;Cần 1 giải thuật đơn giản khi tạo UUID cho tất cả các records của họ.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Và họ quyết định sharding hệ thống MySQL theo &lt;strong&gt;&lt;em&gt;cách của họ&lt;/em&gt;&lt;/strong&gt; như dưới đây.&lt;/p&gt;

&lt;h3 id=&quot;how&quot;&gt;How&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;// Tại sao họ lại chọn MySQL mà ko phải nền tảng khác? Anh kỹ sư có nói trong bài viết là: &lt;a href=&quot;https://engineering.pinterest.com/blog/learn-stop-using-shiny-new-things-and-love-mysql&quot;&gt;Đừng đú theo công nghệ làm gì&lt;/a&gt; , hãy cứ right tool for right job :D&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Đầu tiên, họ bắt đầu với 8 con EC2, mỗi con EC2 (chạy một instance MySQL) lại có 1 con EC2 khác đi kèm, tạo thành 1 cặp với cấu hình master-master (ko phải là master-slave nữa), nhằm mục đích con master ko bị mất dữ liệu ngay cả khi nó bị tèo.
&lt;em&gt;// Nếu con master1 bị tèo, thì lập tức con đi kèm được cho lên làm master luôn. Sau khi con master1 khôi phục thì vai diễn lại đổi thành master1 làm backup cho con đi kèm, cứ như vậy …&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nói phải có sách, mách là phải có hình:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/0*pImQYoxO9l9J3LG8.png&quot; alt=&quot;Mysql infra&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Và mọi thao tác read/write được thực hiện trên con master thôi, con đi kèm chỉ được dùng khi con master có vấn đề.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Trong mỗi con EC2 có nhiều database. Mỗi database này là 1 shard, &lt;strong&gt;có schema structure giống hệt nhau&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lại hình:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/0*dB5aSiZrInFvbefe.png&quot; alt=&quot;Mysql structure&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Họ lưu cấu hình &lt;strong&gt;shard nào, có ID là bao nhiêu? con EC2 nào chứa shard nào? …&lt;/strong&gt; vào ZooKeeper:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[{“range”:     (0,511), “master”: “MySQL001A”, “slave”: “MySQL001B”},
 {“range”: (512, 1023), “master”: “MySQL002A”, “slave”: “MySQL002B”},
    ...
 {“range”: (3072, 3583), “master”: “MySQL007A”, “slave”: “MySQL007B”},
 {“range”: (3584, 4095), “master”: “MySQL008A”, “slave”: “MySQL008B”}]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;// (0,511) tương ứng với db00000 to db00511 ở hình trên.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Tạo UUID (đoạn này mình nghĩ là đoạn hay nhất của film), để có thể phân phối data được viết vào các shard một cách chính xác và balance nhất:
&lt;em&gt;// Đoạn mình sẽ giải thích kỹ, để sau này mình có đọc lại cũng 1 phát hiểu luôn.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Họ tạo UUID là 1 số 64 bit, dùng cho mọi query từ bên ngoài vào, có cấu trúc:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UUID = (shard ID &amp;lt;&amp;lt; 46) | (type ID &amp;lt;&amp;lt; 36) | (local ID&amp;lt;&amp;lt;0)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Với:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shard ID: là 1 số 16bit, có vai trò là ID của shard.&lt;/li&gt;
  &lt;li&gt;type ID: là 1 số 10bit, có vai trò chỉ ra &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt; của &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;. Ví dụ nếu type ID = 1 có nghĩa object type là Pin, type ID = 2 ứng với object type là Board chẳng hạn.&lt;/li&gt;
  &lt;li&gt;local ID: là 1 số 36 bit, có vai trò là ID của records bên trong shard, có giá trị auto increment.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Từ công thức bên trên, có thể thấy UUID được tạo bằng cách:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(Dịch trái shard ID 46 bit) bitwise OR (Dịch trái type ID 36 bit) bitwise OR (Dịch trái local ID 0 bit)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;// Dịch trái, dịch phải thì giống như việc kéo cái cửa trong nhà của tụi Nhật mà mình hay thấy trên film đó. Dịch trái thì kéo cái cửa sang trái, phần bên phải hở ra thì fill toàn bit 0 vào. Dịch phải là kéo cửa sang phải, các bit bị khuất thì bị xoá đi. Nói 1 cách khác, dịch trái làm tăng giá trị của số, dịch phải làm giảm giá trị của số.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;// Dịch trái numberA x bit: là việc fill x bit 0 vào bên phải của numberA ở dạng nhị phân. Ví dụ: numberA = 3 (dạng nhị phân là 11), thực hiện dịch trái numberA 5 bit, ta thu 1100000.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;// bitwise OR: thực hiện OR từng bit từ bên phải sang trái của 2 số dạng nhị phân. Nếu cả 2 bit là 0 thì bit thu được là 0, ngược lại bit thu được là 1. Ví dụ: 8 bitwise OR 22 = 1000 bitwise OR 10110 = 11110 = 30&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;// Do UUID là 1 số 64 bit, nên dù có dịch trái shard ID (có độ dài 16bit) 46bit đi nữa, thì cũng mới chỉ là 1 số 46 + 16 = 62 bit, vẫn dư 2 bit, và vẫn bảo đảm là ko số nào “dẫm” vào đuôi số kia, do số lượng bit dịch bằng tổng độ dài của các số phía trước rồi.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;// Theo mình đánh giá thì đây là 1 cách băm cực hay. Nếu như băm theo kiểu lấy tổng, hay tạo string rồi lấy hash thì ko chính xác, do có nhiều case bị trùng nhau. Và hơn nữa cách này decompose cực đơn giản, khỏi key với kiếc làm gì, sẽ đc giải thích như bên dưới.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Nói thì khó tưởng tượng, đi vào thực tế luôn. Ví dụ với URL:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;https://www.pinterest.com/pin/241294492511762325/, thì UUID nhận được là 241294492511762325.&lt;/code&gt;, sẽ được decompose cái UUID theo cách sau:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shard ID = (241294492511762325 &amp;gt;&amp;gt; 46) &amp;amp; 0xFFFF = 3429
Type ID  = (241294492511762325 &amp;gt;&amp;gt; 36) &amp;amp; 0x3FF = 1 // type Pin -&amp;gt; query vào table pins
Local ID = (241294492511762325 &amp;gt;&amp;gt;  0) &amp;amp; 0xFFFFFFFFF = 7075733
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Từ công thức trên, có thể thấy được:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Shard ID được decompose từ việc &lt;strong&gt;dịch phải 46bit UUID&lt;/strong&gt;, sau đó &lt;strong&gt;bitwise AND với 0xFFFF&lt;/strong&gt; (hay là 0b1111111111111111). Nghĩa là cắt đúng vị trí của Shard ID được dịch trái ở công thức tạo UUID bên trên. Trong trường hợp này thì việc bitwise AND với 0xFFFF là hơi thừa. Tuy nhiên nó lại có ích nếu như Shard ID ko còn đứng ở phía bên trái nhất của 64bit UUID nữa.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type ID&lt;/strong&gt; và &lt;strong&gt;Local ID&lt;/strong&gt; được decompose tương tự, và cần phải bitwise AND tương ứng với 1 số 10bit và 1 số 36bit toàn 1. Như vậy là mọi thông tin cần thiết đã được decompose một cách toàn vẹn, mà lại còn nhanh nữa chứ. Tính toán trên bit mà.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;// Bitwise AND: thực hiện AND từng bit từ bên phải sang trái của 2 số dạng nhị phân. Nếu cả 2 bit là 1 thì bit thu được là 1, ngược lại bit thu được là 0. Ví dụ: 8 bitwise AND 22 = 1000 bitwise AND 10110 = 00000 = 0&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;// Anh kỹ sư nghĩ ra cái trò này có kinh nghiệm với compiler và chip design. Thế mới thấy mấy cha computer science đi thiết kế thì khác bọt thế nào.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sau khi đã có đầy đủ thông tin, chỉ việc query:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;conn = MySQLdb.connect(host=”MySQL007A”)
conn.execute(“SELECT data FROM db03429.pins where local_id=7075733”)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;// Host MySQL007A được nhặt ra từ shard ID 3429, có range nằm trong &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“range”:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(3072,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;3583),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“master”:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“MySQL007A”,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“slave”:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“MySQL007B”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;, nên nó chọn host MySQL007A để query thôi.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Cấu trúc dữ liệu:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Họ phân loại dữ liệu ra 2 loại: Object và Map. Nói nôm na là các table có tính chất là chứa thông tin, và các table có tính chất là tham chiếu. Ví dụ: Pin và Board là kiểu Object, còn board_has_pin là kiểu Map.&lt;/li&gt;
      &lt;li&gt;Ví dụ với table Pin:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE pins (
   local_id INT PRIMARY KEY AUTO_INCREMENT,
   data TEXT,
   ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Để ý thấy là table Pin có bao nhiêu thông tin như thế, vậy mà sao lại có mỗi column data ? Cái hay là họ nhét tất cả các thông tin liên quan đến pin vào column data này, dưới dạng JSON:
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“details”:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“New&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Star&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Wars&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;character”,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“link”:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“http://webpage.com/asdf”,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“user_id”:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;241294629943640797,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“board_id”:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;241294561224164665,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Tại sao? Vì giả sử nếu phải thêm 1 column mới cho 1 table theo cách tiếp cận cũ, thì việc alter table sẽ rất nặng (do phải alter cho tất cả các table tương ứng của các shard). Tuy nhiên với cách làm này, thì khỏi cần alter gì cả, chỉ cần khai báo ở tầng app giá trị default cho column mới mỗi khi muốn đọc ra thôi. Pinterest hơn 3 năm rồi (tính tới thời điểm bài gốc được đăng) chưa từng phải alter table!&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Khi insert 1 record mới, họ chỉ định ghi nó vào shard ID nào, type ID là gì. Sau khi record được insert rồi, nó sẽ trả về local ID, lúc này sẽ kết hợp với Shard ID và Type ID để cho ra UUID theo cách bên trên. Quá lợi hại.&lt;/li&gt;
      &lt;li&gt;Còn với table dạng Map thì có cấu trúc như này:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE board_has_pins (
  board_id INT,
  pin_id INT,
  sequence INT,
  INDEX(board_id, pin_id, sequence)
) ENGINE=InnoDB;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;board_id&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;pin_id&lt;/code&gt; là các UUID 64bit như trên, sequence có dạng timestamp, bảo đảm cho việc order theo created time rồi.&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;// Câu hỏi phát sinh: Vậy giả sử có query: lấy tất cả boards của user X, thì ko lẽ query trên tất cả các shards à? Mình dự là không. Đơn giản là có table users, trong column data có chứa luôn list board rồi. Vì là JSON mà, nó lưu gì chả được. Tiếp cận theo cách của NoSQL là hoàn toàn đúng đắn trong trường hợp này.&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;// Bài viết lược dịch đoạn gây cấn nhất trong phim rồi. Bài gốc vẫn còn 1 đoạn nhắc tới 3 cách scale (scale cấu hình - nâng cấp sức mạnh cho EC2 instance, scale thêm EC2 instance bằng cách tăng số thứ tự của shard ID, và scale thêm instance bằng cách chia nhỏ range của shard ID), và 1 đoạn nhắc tới làm sao map others ID tới pinterest ID nữa, nhưng mình lười, dành phần này cho bạn đọc :))&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;//P/S: Mấy lời tâm sự cuối bài của anh kỹ sư cũng hay.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kết-luận&quot;&gt;Kết luận:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mấy anh to lúc nào cũng đẳng cấp.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 22 Mar 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/tech/mysql/summary/2017/03/22/Pinterest-da-thuc-hien-scaled-MySQL-cua-ho-nhu-the-nao/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/mysql/summary/2017/03/22/Pinterest-da-thuc-hien-scaled-MySQL-cua-ho-nhu-the-nao/</guid>
      </item>
    
      <item>
        <title>Tổ hợp, chỉnh hợp và bài toán đếm cơ bản</title>
        <description>&lt;p&gt;#math #combination #accordant #vi&lt;/p&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;p&gt;Bạn có nhớ gì về hồi cấp 3 ko? Ý mình ko phải là hình ảnh em gái xinh nhất khối mặc áo trong và ngoài có mã màu lần lượt là #000 và #fff đi trong mưa, mà là ít kiến thức về tổ hợp, chỉnh hợp hồi lớp 12 cơ.&lt;/p&gt;

&lt;p&gt;Nếu vững kiến thức này, gần thì bạn sẽ rất nhẹ nhàng làm những bài test nhỏ kiểu như trên codility, paiza. Xa thì có thể ăn chắc 1 trong vài bài test khi đi xin việc :v&lt;/p&gt;

&lt;h3 id=&quot;tổ-hợp-và-chỉnh-hợp&quot;&gt;Tổ hợp và chỉnh hợp&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Tổ hợp: là cách chọn ra K phần tử từ N phần tử (1 &amp;lt;= K &amp;lt;= N), không quan tâm đến thứ tự. Ví dụ, “Các thầy hãy chọn cho tôi 10 giáo viên nữ để đi tiếp khách”. Lúc này thì cứ chọn đủ 10 giáo viên là được, ko quan tâm ai trước ai sau, thì là 1 dạng của tổ hợp.&lt;/li&gt;
  &lt;li&gt;Chỉnh hợp: Tương tự như trên, khác là có quan tâm đến thứ tự. Ví dụ, “Các thầy hãy chọn cho tôi 3 giáo viên để đảm nhiệm các vị trí Phó hiệu trưởng, Bí thư nhà trường và Cán bộ công đoàn”. Lúc này ai vào vị trí nào thì đều có thứ tự rồi, và chỉ cần đổi thứ tự là sẽ có case khác nhau.&lt;/li&gt;
  &lt;li&gt;Vậy, dễ dàng thấy rằng, &lt;strong&gt;Số Chỉnh hợp&lt;/strong&gt; luôn nhiều hơn &lt;strong&gt;Số Tổ hợp&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Công thức &lt;strong&gt;Số Chỉnh hợp&lt;/strong&gt; = &lt;script type=&quot;math/tex&quot;&gt;\frac{N!}{\left( N-K \right)!}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;Công thức &lt;strong&gt;Số Tổ hợp&lt;/strong&gt; = &lt;strong&gt;Số Chỉnh hợp&lt;/strong&gt; / K! = &lt;script type=&quot;math/tex&quot;&gt;\frac{N!}{\left( N-K \right)!K!}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;Tại sao? Các bạn không cần nhớ lại làm gì, mình sẽ trình bày luôn phía dưới. :v&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;số-chỉnh-hợp--fracnleft-n-k-right&quot;&gt;Số Chỉnh hợp = &lt;script type=&quot;math/tex&quot;&gt;\frac{N!}{\left( N-K \right)!}&lt;/script&gt;&lt;/h3&gt;

&lt;p&gt;Quay lại bài toán chọn 10 giáo viên trong số 30 giáo viên để đi tiếp khách. Như vậy, N = 30 và K = 10. Cụ thể:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Giáo viên thứ nhất có 30 cách chọn.&lt;/li&gt;
  &lt;li&gt;Giáo viên thứ hai có 29 cách chọn.&lt;/li&gt;
  &lt;li&gt;Giáo viên thứ ba có 28 cách chọn.&lt;/li&gt;
  &lt;li&gt;….&lt;/li&gt;
  &lt;li&gt;Giáo viên thứ 10 có 21 cách chọn.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Số cách chọn là: &lt;code class=&quot;highlighter-rouge&quot;&gt;30 * 29 * ... * 21&lt;/code&gt; .&lt;br /&gt;
Tổng quát thành: &lt;code class=&quot;highlighter-rouge&quot;&gt;N * (N-1) * ... * (N - K + 1)&lt;/code&gt;.&lt;br /&gt;
Vậy &lt;strong&gt;số chỉnh hợp&lt;/strong&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;N * (N-1) * ... * (N - K + 1)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nhân cả 2 vế với với một lượng &lt;code class=&quot;highlighter-rouge&quot;&gt;(N - K) * (N - K -1) * ... * 2 * 1&lt;/code&gt;, hay chính là &lt;code class=&quot;highlighter-rouge&quot;&gt;(N - K)!&lt;/code&gt;, thu được:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;số chỉnh hợp&lt;/strong&gt; * &lt;code class=&quot;highlighter-rouge&quot;&gt;(N - K)!&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;N * (N-1) * ... * (N - K + 1) * (N - K) * (N - K -1) * ... * 2 * 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mà vế phải chính là N!, nên chia cả 2 vế cho &lt;code class=&quot;highlighter-rouge&quot;&gt;(N - K)!&lt;/code&gt;, thu:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Số Chỉnh hợp&lt;/strong&gt; = &lt;script type=&quot;math/tex&quot;&gt;\frac{N!}{\left( N-K \right)!}&lt;/script&gt; (ĐPCM)&lt;/p&gt;

&lt;h3 id=&quot;số-tổ-hợp--số-chỉnh-hợp--k--fracnleft-n-k-rightk&quot;&gt;Số Tổ hợp = Số Chỉnh hợp / K! = &lt;script type=&quot;math/tex&quot;&gt;\frac{N!}{\left( N-K \right)!K!}&lt;/script&gt;&lt;/h3&gt;

&lt;p&gt;Nhớ lại là &lt;strong&gt;tổ hợp&lt;/strong&gt; thì ko quan tâm đến thứ tự. Nghĩa là với bộ 3 số {1, 2, 3} thì ta có &lt;strong&gt;số chỉnh hợp&lt;/strong&gt; là 3! / (3-3)! = 6 (quy ước 0! = 1)&lt;/p&gt;

&lt;p&gt;Nhưng &lt;strong&gt;số tổ hợp&lt;/strong&gt; thì chỉ là 1 mà thôi, vì ko quan tâm tới thứ tự mà, nên cho dù có bao nhiêu cách sắp xếp khác nhau thì cũng chỉ là một tổ hợp mà thôi.&lt;/p&gt;

&lt;p&gt;Tổng quát lên, &lt;strong&gt;số tổ hợp = số chỉnh hợp / số cách sắp xếp khác nhau của K phần tử&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Mà &lt;strong&gt;số cách sắp xếp khác nhau của K phần tử&lt;/strong&gt; chính bằng &lt;strong&gt;số hoán vị của K&lt;/strong&gt;, hay K!, nên:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Số Tổ hợp&lt;/strong&gt; = &lt;strong&gt;Số Chỉnh hợp&lt;/strong&gt; / K!.&lt;/p&gt;

&lt;p&gt;Thay Số Chỉnh hợp = &lt;script type=&quot;math/tex&quot;&gt;\frac{N!}{\left( N-K \right)!}&lt;/script&gt; thu:&lt;/p&gt;

&lt;p&gt;Số Tổ hợp = &lt;script type=&quot;math/tex&quot;&gt;\frac{N!}{\left( N-K \right)!K!}&lt;/script&gt; (ĐPCM)&lt;/p&gt;

&lt;h3 id=&quot;áp-dụng-cho-bài-toán-đếm-số-tương-tự&quot;&gt;Áp dụng cho bài toán đếm số tương tự&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Một số được cho là tương tự số ban đầu nếu số đó được tạo bởi các chữ số giống với các chữ số của số đã cho và ko xét nếu 0 ở đầu. Ví dụ 113 có 3 số tương tự là 113, 131, 311. Nhưng 100 chỉ có 1 số tương tự là 100 thôi, vì nếu 001 hay 010 thì ko hợp lệ.&lt;/li&gt;
  &lt;li&gt;Vậy có cách nào tổng quát để tính số lượng số tương tự của 1 số cho trước không?&lt;/li&gt;
  &lt;li&gt;Trước hết hãy cùng xem xét một bài toán có tên &lt;a href=&quot;http://web.mit.edu/neboat/Public/6.042/counting3.pdf&quot;&gt;Bookkeeper Rule&lt;/a&gt; dưới đây.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bookkeeper-rule&quot;&gt;&lt;a href=&quot;http://web.mit.edu/neboat/Public/6.042/counting3.pdf&quot;&gt;Bookkeeper Rule&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Là công thức tính số cách sắp xếp các chữ cái trong từ &lt;code class=&quot;highlighter-rouge&quot;&gt;bookkeeper&lt;/code&gt; theo các cách khác nhau. Ví dụ ta sẽ có &lt;code class=&quot;highlighter-rouge&quot;&gt;bokokeeper&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bkookeeper&lt;/code&gt; …&lt;/p&gt;

&lt;p&gt;Công thức được viết thành:&lt;br /&gt;
Số cách xếp = &lt;script type=&quot;math/tex&quot;&gt;\frac{10!}{1!2!2!3!1!1!}&lt;/script&gt; = 302400 cách xếp.&lt;/p&gt;

&lt;p&gt;Các con số trên lấy ở đâu ra?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;10 = độ dài của xâu bookkeeper&lt;/li&gt;
  &lt;li&gt;1, 2, 2, 3, 1, 1 lần lượt là số lần xuất hiện của &lt;code class=&quot;highlighter-rouge&quot;&gt;b, o, k, e, p, r&lt;/code&gt; trong xâu &lt;code class=&quot;highlighter-rouge&quot;&gt;bookkeeper&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Như vậy, nếu áp dụng Bookkeeper rule cho bài toán số tương tự, ta phải xét thêm trường hợp số 0 đứng đầu.
Do &lt;strong&gt;cứ có số 0 đứng đầu thì số tạo thành là ko hợp lệ&lt;/strong&gt;, nên &lt;strong&gt;mọi cách sắp xếp của các chữ số còn lại trong trường hợp có số 0 ở đầu là không hợp lệ&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Vậy đơn giản là chỉ cần lấy &lt;strong&gt;tổng các số tương tự&lt;/strong&gt; trừ đi &lt;strong&gt;tổng số cách mà có 0 đứng đầu&lt;/strong&gt; là sẽ thu được kết quả đúng.&lt;/p&gt;

&lt;p&gt;Và cũng có thể áp dụng Bookkeeper rule cho &lt;strong&gt;các chữ số còn lại trong trường hợp có số 0 ở đầu&lt;/strong&gt; để thu được số các số mà bắt đầu bằng 0.&lt;/p&gt;

&lt;p&gt;Vậy có thể viết thành công thức tổng quát như sau:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;numbers_start_with_0 = if(original_number.contains(0)) bookkeeper(original_number.remove_one(0)) else 0
simillar_numbers = bookkeeper(original_number) - numbers_start_with_0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Mình có viết một đoạn code bằng Ruby minh hoạ cho công thức trên như sau:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Calculate number of Similar Numbers
# 112 has 112, 121, 211 (3 similar numbers)
# 100 has 100 (1 similar number)
# Given integer a (1 &amp;lt;= a &amp;lt;= 2^32)
# Calculate number of similar numbers of a

def permute(n)
  return 1 if n == 0
  (1..n).reduce(:*)
end

# BookKeeper Rule
# http://web.mit.edu/neboat/Public/6.042/counting3.pdf
#
# group_digits has format:
# {digit1 =&amp;gt; number_digits1, digit2 =&amp;gt; number_digits2}
def bookkeeper(group_digits)
  number_digits       = 0
  denominator_permute = 1
  group_digits.each do |_, n_digits|
    number_digits       += n_digits
    denominator_permute *= permute(n_digits)
  end
  permute(number_digits) / denominator_permute
end

def solution(a)
  digits       = a.to_s.split('')
  group_digits = Hash.new(0).tap { |h| digits.each { |d| h[d.to_i] += 1 } }
  total_cases  = bookkeeper(group_digits)

  # Remove all similar numbers that start with 0
  # Means: If similar number start with 0,
  # all other similar numbers that is created by other digits will be invalid
  unless group_digits[0] == 0
    group_digits[0] = group_digits[0] - 1
    total_cases     -= bookkeeper(group_digits)
  end

  total_cases
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Make #cấp3 great again!&lt;/p&gt;

</description>
        <pubDate>Wed, 22 Mar 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/math/basic/2017/03/22/to-hop-chinh-hop/</link>
        <guid isPermaLink="true">http://localhost:4000/math/basic/2017/03/22/to-hop-chinh-hop/</guid>
      </item>
    
      <item>
        <title>Thực hiện benchmark (BM) MySQL InnoDB Buffer Pool(BP) trước và sau khi được warmup</title>
        <description>&lt;p&gt;#tech #mysql #innodb #bufferpool #mytool #vi&lt;/p&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;p&gt;Với những database có lượng read lớn thì tầm quan trọng của việc warmup BP đã được nhắc tới nhiều. Nhưng nó có hiệu quả tới mức như thế nào? Mình đã thực hiện 1 BM đơn giản, với một table cũng đơn giản để cho thấy sự khác biệt trước và sau khi warmup.&lt;/p&gt;

&lt;h3 id=&quot;môi-trường&quot;&gt;Môi trường:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mysql --version
mysql  Ver 14.14 Distrib 5.7.14, for osx10.11 (x86_64) using  EditLine wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CoreI5 @2.6GHz, DDR3 8GB@1600MHz, SSD&lt;/p&gt;

&lt;h3 id=&quot;chuẩn-bị&quot;&gt;Chuẩn bị:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Một MySQL instance KHÔNG CẤU HÌNH LOAD BP khi startup:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; show variables like '%buffer_pool%';
+-------------------------------------+----------------+
| Variable_name                       | Value          |
+-------------------------------------+----------------+
| innodb_buffer_pool_chunk_size       | 268435456      |
| innodb_buffer_pool_dump_at_shutdown | OFF            |
| innodb_buffer_pool_dump_now         | OFF            |
| innodb_buffer_pool_dump_pct         | 25             |
| innodb_buffer_pool_filename         | ib_buffer_pool |
| innodb_buffer_pool_instances        | 1              |
| innodb_buffer_pool_load_abort       | OFF            |
| innodb_buffer_pool_load_at_startup  | OFF            |
| innodb_buffer_pool_load_now         | OFF            |
| innodb_buffer_pool_size             | 268435456      |
+-------------------------------------+----------------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Một table với structure đơn giản như sau:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; desc test_data;
+-------------+--------------+------+-----+---------+----------------+
| Field       | Type         | Null | Key | Default | Extra          |
+-------------+--------------+------+-----+---------+----------------+
| id          | int(11)      | NO   | PRI | NULL    | auto_increment |
| random_str  | varchar(255) | YES  | MUL | NULL    |                |
| random_str2 | varchar(255) | YES  |     | NULL    |                |
+-------------+--------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Với 10triệu records:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; select count(*) from test_data;
+----------+
| count(*) |
+----------+
| 10000000 |
+----------+
1 row in set (8.38 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Một file SQL chứa 20k câu query để thực hiện BM, có format:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from test_data where random_str = &quot;unique_string_value&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Với &lt;code class=&quot;highlighter-rouge&quot;&gt;unique_string_value&lt;/code&gt; lần lượt là các giá trị lấy ra từ &lt;code class=&quot;highlighter-rouge&quot;&gt;random_str&lt;/code&gt; của table trên.&lt;/p&gt;

&lt;h3 id=&quot;kịch-bản-bm&quot;&gt;Kịch bản BM&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Step0: Khởi động MySQL với option chỉ định KHÔNG LOAD, KHÔNG DUMP BP, và init BP size là 256MB:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mysql.server start --innodb_buffer_pool_load_at_startup=0 --innodb_buffer_pool_dump_at_shutdown=0 --innodb_buffer_pool_chunk_size=256M --innodb_buffer_pool_size=256M
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Step1: Chạy BM command khi không dùng tool &lt;a href=&quot;https://github.com/manhdaovan/mysql_warmup&quot;&gt;mysql-warmup&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mysqlslap --create-schema=warmup_benchmark --delimiter=&quot;;&quot; --query=benchmark_query_20000_rows.sql --concurrency=1 --iterations=1 -uroot -p
Enter password:
Benchmark
    Average number of seconds to run all queries: 7.562 seconds
    Minimum number of seconds to run all queries: 7.562 seconds
    Maximum number of seconds to run all queries: 7.562 seconds
    Number of clients running queries: 1
    Average number of queries per client: 20001
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ý nghĩa câu lệnh trên là: Mô phỏng 1 client, thực hiện 20k queries, mỗi query là 1 câu select theo value của column random_str (column này đã được index).&lt;br /&gt;
Giả sử câu lệnh BM chuyển thành: Mô phỏng 20k clients, query cùng 1 nội dung, thì BM ko có ý nghĩa.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Step2: Chạy cùng câu lệnh như trên ngay sau đó, để thấy sự khác biệt khi BP được hit thay vì hit vào disk:&lt;/strong&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mysqlslap --create-schema=warmup_benchmark --delimiter=&quot;;&quot; --query=benchmark_query_20000_rows.sql --concurrency=1 --iterations=1 -uroot -p
Enter password:
Benchmark
  Average number of seconds to run all queries: 1.740 seconds
  Minimum number of seconds to run all queries: 1.740 seconds
  Maximum number of seconds to run all queries: 1.740 seconds
  Number of clients running queries: 1
  Average number of queries per client: 20001
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Step 3: Tắt mysql, Khởi động lại máy (cho chắc, tránh MySQL rơi vào sleep mode), sau đó khởi động MySQL service lên như Step0.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Step4: Chạy mysql-warmup tool:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mysql-warmup -uroot -dwarmup_benchmark

Input the mysql password:
my_mysql_root_password
2017-02-24 15:33:07 +0900: --- &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; START WARMUP FOR DB: warmup_benchmark &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
2017-02-24 15:33:07 +0900: --- START WARMUP FOR TABLE:   `warmup_benchmark`.`test_data`
2017-02-24 15:33:29 +0900: --- SUCCESS WARMUP FOR TABLE: `warmup_benchmark`.`test_data`

2017-02-24 15:33:29 +0900: --- +++++++ SUCCESS WARMUP FOR DB: warmup_benchmark +++++++
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Step5: Chạy lại câu lệnh BM như Step1:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mysqlslap --create-schema=warmup_benchmark --delimiter=&quot;;&quot; --query=benchmark_query_20000_rows.sql --concurrency=1 --iterations=1 -uroot -p
Enter password:
Benchmark
    Average number of seconds to run all queries: 2.132 seconds
    Minimum number of seconds to run all queries: 2.132 seconds
    Maximum number of seconds to run all queries: 2.132 seconds
    Number of clients running queries: 1
    Average number of queries per client: 20001
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Step6: Chạy lại câu lệnh như trên một lần nữa, xem có sự khác biệt nào không:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mysqlslap --create-schema=warmup_benchmark --delimiter=&quot;;&quot; --query=benchmark_query_20000_rows.sql --concurrency=1 --iterations=1 -uroot -p
Enter password:
Benchmark
    Average number of seconds to run all queries: 1.886 seconds
    Minimum number of seconds to run all queries: 1.886 seconds
    Maximum number of seconds to run all queries: 1.886 seconds
    Number of clients running queries: 1
    Average number of queries per client: 20001
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;kết-luận&quot;&gt;Kết luận:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Nhìn vào kết quả ở Step1 và Step5: 7.562 seconds vs 2.132 seconds cho những request đầu tiên. Không tệ lắm nhỉ.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ps-câu-hỏi-dành-cho-bạn-đọc&quot;&gt;P/S: Câu hỏi dành cho bạn đọc:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Tại sao kết quả ở Step2(1.740 seconds) lại nhanh hơn ở Step5(2.132 seconds) ?&lt;/li&gt;
  &lt;li&gt;Tại sao kết quả ở Step6(1.886 seconds) lại nhanh hơn ở Step5(2.132 seconds), nhưng lại chậm hơn ở Step2(1.740 seconds)?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bạn có thể đọc &lt;a href=&quot;https://github.com/manhdaovan/mysql_warmup/blob/master/BENCHMARK.md&quot;&gt;bản tiếng Anh ở đây&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Mar 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/tech/mysql/mytool/2017/03/02/benchmark-mysql-inno-db-buffer-pool/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/mysql/mytool/2017/03/02/benchmark-mysql-inno-db-buffer-pool/</guid>
      </item>
    
      <item>
        <title>So sánh các câu lệnh warmup primary key vào buffer pool với engine InnoDB mysql</title>
        <description>&lt;p&gt;#tech #mysql #vi&lt;/p&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_buffer_pool&quot;&gt;Buffer pool(BF)&lt;/a&gt; của mysql quả thực có nhiều lợi ích, và việc warm up BP luôn là việc nên làm đầu tiên mỗi khi start/reload/create new mysql.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mysql version &amp;gt;= 5.6 đã hỗ trợ đơn giản hoá việc save/restore BF state bằng cấu hình, nên việc cần làm chỉ là cấu hình là xong.&lt;/li&gt;
  &lt;li&gt;Và trong các case khác, như cấu hình 1 slave mới, hoặc mysql version &amp;lt; 5.6, thì phải thực hiện việc này một cách thủ công. Cơ chế chung của việc warmup là “touch” vào primary key và index của table đó.&lt;/li&gt;
  &lt;li&gt;Tuy nhiên, “touch” thế nào cho tối ưu nhất? Trong quá trình thực hiện benchmark cho &lt;a href=&quot;https://github.com/manhdaovan/mysql_warmup&quot;&gt;tool này&lt;/a&gt;, người viết thấy có 1 số điều thú vị như dưới đây.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;testing&quot;&gt;Testing&lt;/h3&gt;

&lt;p&gt;Việc testing theo các case khác nhau khá dài, và chủ yếu là người viết cực kỳ lười :v, nên các bạn vui lòng đọc tại &lt;a href=&quot;https://github.com/manhdaovan/mysql_warmup/blob/master/CHANGE_SUM_TO_COUNT.md&quot;&gt;link này&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;tldr&quot;&gt;TL;DR&lt;/h3&gt;

&lt;p&gt;Để warmup primary key của table, thì câu lệnh nào dưới đây là tối ưu trong trường hợp:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Table chỉ có primary key.&lt;/li&gt;
  &lt;li&gt;Table ngoài primary key ra còn có nhiều hơn hoặc bằng một index nữa&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Các câu lệnh thử nghiệm:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;select count(*) from table_name&lt;/li&gt;
  &lt;li&gt;select count(*) from table_name where non_index_column = 0 or non_index_column = ‘0’&lt;/li&gt;
  &lt;li&gt;select sum(primary_key) from table_name ?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;kết-quả&quot;&gt;Kết quả:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Table with only primary key:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;select count(*) from table_name where non_index_column = 0 or non_index_column = '0'&lt;/code&gt; cho kết quả nhiều pages được load vào BF là nhiều nhất.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;select count(*) from table_name&lt;/code&gt; và &lt;code class=&quot;highlighter-rouge&quot;&gt;select sum(primary_key) from table_name&lt;/code&gt; cho cùng 1 kết quả số pages được load, nhưng ít hơn câu trên.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Table with primary key and other index(es):&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;select count(*) from table_name&lt;/code&gt;: &lt;strong&gt;primary_key&lt;/strong&gt; will be loaded.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;select sum(primary_key) from table_name&lt;/code&gt;: &lt;strong&gt;other_index&lt;/strong&gt; will be loaded, not primary key (so funny).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;select count(*) from table_name where non_index_column = 0 or non_index_column = '0'&lt;/code&gt;: &lt;strong&gt;primary_key&lt;/strong&gt; sẽ đựơc load với số lượng lớn nhất.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kết-luận&quot;&gt;Kết luận:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Nên manual bằng cách touch primary key theo cách đảm bảo là tất cả primary key sẽ được “sờ” tới, bằng cách add thêm điều kiện where cho non_index_column.&lt;/li&gt;
  &lt;li&gt;Nên dùng &lt;strong&gt;count(*)&lt;/strong&gt; thay cho &lt;strong&gt;sum(primary_key)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/tech/mysql/mytool/2017/01/16/so-sanh-warmup-commands/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/mysql/mytool/2017/01/16/so-sanh-warmup-commands/</guid>
      </item>
    
      <item>
        <title>Muốn đi Nhật - Cần làm gì?</title>
        <description>&lt;p&gt;Từ topic mình hỏi về việc quá hạn Landing permission và Special re-entry permission tại &lt;a href=&quot;https://goo.gl/ciOWq9&quot;&gt;đây&lt;/a&gt;,
thì một số bạn có pm và đặt câu hỏi là bạn ấy có nhu cầu qua Nhật làm việc theo dạng kỹ sư, vậy cần chuẩn bị hoặc làm gì để có thể sang Nhật làm việc được?&lt;/p&gt;

&lt;p&gt;Trước khi đi vào câu trả lời thì mình xin nói trước là kinh nghiệm đi Nhật của mình không phong phú,
và hơn nữa mình cũng không có kinh nghiệm tư vấn lắm, chỉ là mình nói dựa trên những điều bản thân mình đã trải qua.&lt;/p&gt;

&lt;p&gt;Trước tiên là nói về việc sang Nhật theo dạng kỹ sư thì khác với dạng khác (Tu nghiệp sinh, lao động phổ thông…) như thế nào.
Mình thấy có 3 điểm khác biệt lớn nhất:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Phí đầu vào:&lt;/strong&gt;
Hiện tại theo mình thấy nếu đi theo con đường Tu Nghiệp Sinh, thì phí đầu vào rất cao, từ 10k$ cho tới 15k$, tùy Trung tâm môi giới.
Tuy nhiên, với chế độ kỹ sư, thì gần như bạn không phải mất một khoản phí đầu vào nào. Dù có phải trả một khoản phí nào đó cho các công ty head hunter
nhưng đó là phía công ty trả, các bạn không phải bận tâm vấn đề này.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Công việc:&lt;/strong&gt;
Mỗi ngành mỗi nghề có cái khó cái khổ khác nhau, nói là tôi làm khổ hơn anh, hoặc anh làm nhàn hơn tôi là điều rất khó.
Tuy nhiên, với công việc dạng kỹ sư, thì kể cả công ty có phá sản, họ cũng có trách nhiệm giới thiệu cho mình một công việc khác phù hợp,
đảm bảo mình không phải về nước sớm hơn dự định khi ký hợp đồng với họ. Điều này là rất tốt, và mình cũng có bạn gặp trường hợp này rồi. Phía công ty tiếp nhận mình họ chơi rất đẹp.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Môi trường:&lt;/strong&gt;
Với phận Tu nghiệp sinh (mình nói cụ thể trường hợp này vì bạn bè và ở quê mình có rất nhiều và hầu hết trường hợp là đi theo con đường này)
được công ty môi giới giới thiệu với mức lương 25-40 triệu/tháng, nghe thì có vẻ như mình có thể giầu lên ngay được, nhưng thực tế là thân mình như hạt mưa.
Hạt thì rơi luống hoa cười, hạt thì rơi xuống giếng mà ngậm ngùi. Thực tế thế nào thì các bạn cũng nghe và cũng biết, mình không nói cụ thể,
nhưng quả thực là rất bấp bênh. Với chi phí cao, khi sang tới nơi lại không có việc, áp lực về việc kiếm tiền đè nặng, nhiều bạn bỏ học nhảy ra ngoài làm,
hoặc quẫn hơn là đi ăn cắp, ăn trộm. Đây cũng là một trong các nguyên nhân làm tỷ lệ tội phạm người VN ở Nhật gia tăng nhanh chóng. Buồn.
Còn với phận Kỹ sư thì như điều 2 mình nói ở trên thì công việc luôn đảm bảo, trừ khi bạn quá chán mà nghỉ về nước. Cái này lại là khía cạnh khác, xin phép không bàn tới.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tiếp theo, mình đi vào câu trả lời cho câu hỏi từ đầu, là cần làm gì để sang Nhật dạng kỹ sư được?
Để làm được điều này thì điều kiện CẦN (chứ không phải đủ, vì nếu để chắc chắn sang được thì lại phụ thuộc nhiều yếu tố nữa):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Lên kế hoạch về việc sẽ đi Nhật càng sớm càng tốt.&lt;/strong&gt;
Đừng để đến khi bạn học hết Cao Đẳng, Đại Học, xin mãi không được việc, hoặc có việc nhưng lương thấp, kêu chán ầm trời,
Bố Mẹ thì sốt ruột, lại đang loay hoay tài chính thì mới có quyết định đi Nhật kiếm tiền. Quá nhiều và hầu hết các bạn cứ học hết lớp 12,
đi học Trung cấp hoặc Cao đẳng vài năm rồi, vẫn cứ bơ vơ rồi mới bắt đầu quay sang con đường xuất khẩu lao động. Đây là điều hết sức không hay.
Thay vì như thế hãy quyết tâm đi Nhật ngay từ khi vừa hết lớp 12 hoặc năm 1 ĐH, để làm tiền đề thực hiện các bước sau.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Học tiếng Nhật.&lt;/strong&gt;
Có kế hoạch rồi thì làm gì? N3 là chứng chỉ tối thiểu bạn cần có nếu muốn các công ty mời đón bạn. Khi sang tới nơi mà không biết tiếng thì chẳng khác gì như câm như điếc.
Tất nhiên không bàn tới các bạn bắn tiếng Anh ầm ầm, hoặc làm việc ở môi trường đặc thù.
Bạn học Trung Cấp cũng được, Cao Đẳng cũng được, nhưng Tiếng Nhật phải ngon. Thời sinh viên là thời có rất nhiều thời gian, tranh thủ mà học là tốt nhất, chứ đừng học ĐH 4, 5 năm rồi,
tốt nghiệp, ra trường mới đi học Tiếng Nhật, vừa tốn thời gian, mà khả năng tiếp thu đã kém đi nhiều so với hồi sinh viên.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Lựa chọn trường Đại học.&lt;/strong&gt;
Như đã nói ở trên, muốn sang Nhật làm việc thì nhà tuyển dụng phải biết bạn. Muốn được nhà tuyển dụng(các công ty Nhật bản) biết đến bạn thì thường có 2 cách:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Qua công ty môi giới - head hunter.&lt;/strong&gt; (Cái này áp dụng cho các bạn còn đang chưa biết bắt đầu từ đâu)
 Công ty môi giới mà mình đang đề cập đây khác với các công ty môi giới xuất khẩu lao động mình nói ở trên. Khác cái gì? Đó là họ có trách nhiệm tìm người phù hợp công việc.
 Khi bạn là người họ tìm và ký hợp đồng thành công với cty phía Nhật thì cty phía Nhật sẽ có trách nhiệm trả phí môi giới chứ không phải bạn.
 Bạn gần như không mất khoản phí nào cả. Với đối tượng này thì các bạn hãy gửi CV cho họ, nếu được họ chấp nhận thì khả năng đi Nhật của bạn là cao,
 nếu không thì cũng sẽ làm cho các công ty Nhật ở VN. Điều quan trọng để được nhận là tiếng Nhật phải ngon. Năng lực thì có thể bình thường, nhưng tiếng Nhật thì càng ngon càng tốt.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Các buổi tuyển dụng ở trường.&lt;/strong&gt;
 Như mình biết thì các bạn nên học những ngôi trường có liên kết đào tạo với Nhật Bản như ĐH Bách Khoa HN, ĐH Công Nghiệp HN,
 mà nếu vào được những khoa mà Nhật trực tiếp liên kết đào tạo thì càng ngon, như trường hợp của mình thì là Chương trình Việt Nhật của Bách Khoa HN.
 Vào mỗi kỳ cuối của năm thứ 4 luôn có một đợt tuyển dụng. Khi ấy, các công ty của Nhật Bản trực tiếp sang và phỏng vấn, nếu pass thì chắc chắn sẽ qua Nhật làm việc.
 Tất nhiên là vẫn không mất khoản phí nào.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nói dài như vậy nhưng tóm lại như sau:
Để có thể sang Nhật làm việc dạng kỹ sư (không đề cập đến hình thức khác ở đây), thì cần:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Xác định mục tiêu ngay từ đầu, từ năm 1 ĐH thì càng tốt.&lt;/li&gt;
  &lt;li&gt;Học tiếng Nhật ngay và luôn khi đã xác định mục tiêu.&lt;/li&gt;
  &lt;li&gt;Chăm chỉ liên hệ với các công ty tuyển dụng, hoặc tích cực tham gia các buổi tuyển dụng trực tiếp.&lt;/li&gt;
  &lt;li&gt;Khi đã được công ty Nhật nhận vào làm thì việc lo thủ tục Visa chỉ là vấn đề thời gian, họ sẽ có hướng dẫn cụ thể cho mình.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Trên đây là vài dòng tâm sự dựa trên kinh nghiệm bản thân mình.
Chúc bạn may mắn và đạt được công việc mong muốn.&lt;/p&gt;
</description>
        <pubDate>Fri, 26 Jun 2015 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/opinion/career/2015/06/26/muon-sang-nhat-thi-lam-gi/</link>
        <guid isPermaLink="true">http://localhost:4000/opinion/career/2015/06/26/muon-sang-nhat-thi-lam-gi/</guid>
      </item>
    
  </channel>
</rss>
